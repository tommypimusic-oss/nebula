<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Idea Nebula | The Collective</title>
    
    <!-- 1. Styles & Icons -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <style>
      body { background-color: #000000; color: white; margin: 0; overflow: hidden; }
      ::-webkit-scrollbar { width: 6px; }
      ::-webkit-scrollbar-track { background: #000; }
      ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
      ::-webkit-scrollbar-thumb:hover { background: #555; }
      
      .fade-in { animation: fadeIn 0.3s ease-out; }
      @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    </style>

    <!-- 2. React & Babel -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <!-- 3. Application Logic -->
    <script type="text/babel" data-type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, orderBy, limit, serverTimestamp } 
        from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // ðŸ”´ PASTE YOUR FIREBASE CONFIG HERE ðŸ”´
const firebaseConfig = {
  apiKey: "AIzaSyBCBXsY55rxtKUx2HYXA7riczMRTiRKgMA",
  authDomain: "idea-nebula.firebaseapp.com",
  projectId: "idea-nebula",
  storageBucket: "idea-nebula.firebasestorage.app",
  messagingSenderId: "606687457668",
  appId: "1:606687457668:web:cdca14efacc9516b2aedd1",
  measurementId: "G-HGDDEJ8N20"
};

        let app, db, auth;
        try {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
        } catch (e) {
            console.error("Firebase Config Error:", e);
        }

        const { useState, useEffect, useRef } = React;

        // --- UTILS ---
        
        // Better Pseudo-Random Hash: Ensures uniform distribution
        // Takes a string (ID) and a seed (e.g. 'x' or 'y') to produce a number 0..1
        const getSeededRandom = (str, axis) => {
            let h = 0xdeadbeef;
            str = str + axis; // Mix the axis into the hash
            for(let i = 0; i < str.length; i++)
                h = Math.imul(h ^ str.charCodeAt(i), 2654435761);
            return ((h ^ h >>> 16) >>> 0) / 4294967296;
        }

        const generateRemix = (texts) => {
            let pool = [];
            texts.forEach(text => {
                const lines = text.split(/[\n.]+/);
                lines.forEach(line => {
                    const clean = line.trim();
                    if (clean.length > 5) pool.push(clean);
                });
            });

            if (pool.length === 0) return "The void is silent.";
            pool.sort(() => Math.random() - 0.5);

            const output = [];
            let currentLine = pool.shift();
            output.push(currentLine);

            const targetLength = Math.floor(Math.random() * 5) + 3;

            while (output.length < targetLength && pool.length > 0) {
                const currentWords = new Set(currentLine.toLowerCase().match(/\b[a-z]{3,}\b/g) || []);
                let foundMatch = false;
                
                for (let i = 0; i < pool.length; i++) {
                    const candidate = pool[i];
                    const candidateWords = new Set(candidate.toLowerCase().match(/\b[a-z]{3,}\b/g) || []);
                    const intersection = new Set([...currentWords].filter(x => candidateWords.has(x)));
                    
                    if (intersection.size > 0) {
                        currentLine = pool.splice(i, 1)[0];
                        output.push(currentLine);
                        foundMatch = true;
                        break;
                    }
                }
                if (!foundMatch) {
                    currentLine = pool.shift();
                    output.push(currentLine);
                }
            }
            return output.join('\n');
        };

        // --- MAIN COMPONENT ---
        function IdeaNebula() {
            const [ideas, setIdeas] = useState([]);
            const [hoveredNode, setHoveredNode] = useState(null);
            const [selectedNode, setSelectedNode] = useState(null);
            const [searchTerm, setSearchTerm] = useState('');
            const [user, setUser] = useState(null);
            
            const [showAddModal, setShowAddModal] = useState(false);
            const [showRemixModal, setShowRemixModal] = useState(false);
            const [remixResult, setRemixResult] = useState('');
            const [remixSources, setRemixSources] = useState([]);
            
            const [newContent, setNewContent] = useState('');
            const [isSubmitting, setIsSubmitting] = useState(false);

            const canvasRef = useRef(null);
            const requestRef = useRef();

            // 1. AUTH & DATA
            useEffect(() => {
                if (!auth || !db) return;

                const unsubAuth = onAuthStateChanged(auth, (currentUser) => {
                    if (currentUser) setUser(currentUser);
                    else signInAnonymously(auth).catch(console.error);
                });

                const q = query(collection(db, "ideas"), orderBy("timestamp", "desc"), limit(2000));
                
                const unsubData = onSnapshot(q, (snapshot) => {
                    const loadedIdeas = snapshot.docs.map(doc => {
                        const data = doc.data();
                        
                        // Use improved hash for X/Y
                        const randX = getSeededRandom(doc.id, 'x');
                        const randY = getSeededRandom(doc.id, 'y');
                        
                        // Add padding (10%) so stars don't hug the edge
                        const padding = 0.1;
                        const w = window.innerWidth;
                        const h = window.innerHeight;

                        return {
                            id: doc.id,
                            content: data.content,
                            // Map 0..1 to Padding..1-Padding
                            x: (padding * w) + (randX * (w * (1 - padding * 2))),
                            y: (padding * h) + (randY * (h * (1 - padding * 2))),
                            timestamp: data.timestamp,
                            glimmer: null
                        };
                    });
                    setIdeas(loadedIdeas);
                });

                return () => { unsubAuth(); unsubData(); };
            }, []);

            // 2. DRAW
            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Glimmer
                if (ideas.length > 0 && Math.random() < 0.1) {
                    const target = ideas[Math.floor(Math.random() * ideas.length)];
                    if (!target.glimmer) {
                        const colors = ['#facc15', '#ffffff', '#fb923c', '#ef4444'];
                        target.glimmer = { life: 1.0, color: colors[Math.floor(Math.random() * colors.length)] };
                    }
                }

                ideas.forEach(node => {
                    const matchesSearch = searchTerm && node.content.toLowerCase().includes(searchTerm.toLowerCase());
                    const isDimmed = searchTerm && !matchesSearch;
                    
                    let color = '#ffffff';
                    let radius = 2;
                    let glow = 0;

                    if (node.id === selectedNode?.id || remixSources.includes(node.id)) {
                        color = '#facc15'; radius = 4; glow = 15;
                    } else if (node.id === hoveredNode?.id) {
                        color = '#facc15'; radius = 3; glow = 10;
                    } else if (matchesSearch) {
                        color = '#facc15'; radius = 3;
                    } else if (isDimmed) {
                        color = '#333333';
                    } else if (node.glimmer) {
                        color = node.glimmer.color; radius = 3; glow = 10;
                        node.glimmer.life -= 0.02;
                        if (node.glimmer.life <= 0) node.glimmer = null;
                    }

                    ctx.beginPath();
                    ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.shadowBlur = glow;
                    ctx.shadowColor = color;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });

                // Lines
                if (remixSources.length > 1) {
                    const nodes = ideas.filter(i => remixSources.includes(i.id));
                    if (nodes.length > 1) {
                        ctx.beginPath();
                        ctx.strokeStyle = '#facc15';
                        ctx.lineWidth = 0.5;
                        ctx.globalAlpha = 0.6;
                        ctx.moveTo(nodes[0].x, nodes[0].y);
                        for(let i=1; i<nodes.length; i++) ctx.lineTo(nodes[i].x, nodes[i].y);
                        ctx.lineTo(nodes[0].x, nodes[0].y);
                        ctx.stroke();
                        ctx.globalAlpha = 1.0;
                    }
                }
                requestRef.current = requestAnimationFrame(draw);
            };

            useEffect(() => {
                const handleResize = () => {
                    if(canvasRef.current) {
                        canvasRef.current.width = window.innerWidth;
                        canvasRef.current.height = window.innerHeight;
                    }
                };
                window.addEventListener('resize', handleResize);
                handleResize();
                requestRef.current = requestAnimationFrame(draw);
                return () => cancelAnimationFrame(requestRef.current);
            }, [ideas, hoveredNode, selectedNode, searchTerm, remixSources]);

            // 3. HANDLERS
            const handleMouseMove = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                let found = null;
                for (let i = ideas.length - 1; i >= 0; i--) {
                    const node = ideas[i];
                    if (Math.hypot(node.x - x, node.y - y) < 15) { found = node; break; }
                }
                setHoveredNode(found);
            };

            const handleClick = () => {
                if (hoveredNode) { setSelectedNode(hoveredNode); }
                else { setSelectedNode(null); setRemixSources([]); }
            };

            const handleAddIdea = async () => {
                if (!newContent.trim() || !db) return;
                if (!user) { alert("Connecting... please wait."); return; }
                setIsSubmitting(true);
                try {
                    await addDoc(collection(db, "ideas"), {
                        content: newContent,
                        timestamp: serverTimestamp(),
                        source: "anonymous"
                    });
                    setNewContent('');
                    setShowAddModal(false);
                } catch (e) { alert("Transmission failed."); } 
                finally { setIsSubmitting(false); }
            };

            const handleRemix = () => {
                if (ideas.length < 3) { alert("Not enough data in the void yet."); return; }
                const count = Math.floor(Math.random() * 3) + 3;
                const shuffled = [...ideas].sort(() => 0.5 - Math.random());
                const selected = shuffled.slice(0, count);
                const result = generateRemix(selected.map(i => i.content));
                setRemixResult(result);
                setRemixSources(selected.map(i => i.id));
                setShowRemixModal(true);
            };

            return (
                <div className="w-screen h-screen bg-black overflow-hidden font-sans text-white select-none relative">
                    <canvas ref={canvasRef} className="absolute inset-0 z-0 cursor-crosshair" onMouseMove={handleMouseMove} onClick={handleClick} />

                    {/* TOP BAR */}
                    <div className="absolute top-0 left-0 w-full p-6 flex justify-between items-start z-10 pointer-events-none">
                        <div>
                            <h1 className="text-3xl font-light tracking-[0.2em] text-white opacity-90">IDEA NEBULA</h1>
                            <div className="text-xs mt-2 font-mono flex items-center gap-2">
                                <span className={`w-2 h-2 rounded-full ${user ? 'bg-green-500 animate-pulse' : 'bg-red-500'}`}></span>
                                {user ? <span className="text-green-500">CONNECTED â€¢ {ideas.length} NODES</span> : <span className="text-red-500">DISCONNECTED</span>}
                            </div>
                        </div>
                        <div className="flex gap-3 pointer-events-auto">
                            <div className="bg-zinc-900/80 backdrop-blur border border-zinc-800 rounded-full px-4 py-2 flex items-center gap-2 shadow-lg w-64 focus-within:w-80 transition-all">
                                <i className="ph ph-magnifying-glass text-zinc-400"></i>
                                <input type="text" placeholder="Search the void..." value={searchTerm} onChange={(e) => setSearchTerm(e.target.value)} className="bg-transparent border-none outline-none text-sm w-full text-white placeholder-zinc-500" />
                            </div>
                            <button onClick={() => setShowAddModal(true)} className="bg-zinc-100 hover:bg-white text-black p-3 rounded-full shadow-lg transition-transform hover:scale-105">
                                <i className="ph ph-plus text-lg font-bold"></i>
                            </button>
                        </div>
                    </div>

                    {/* REMIX BUTTON */}
                    <div className="absolute bottom-10 left-1/2 -translate-x-1/2 z-10 pointer-events-auto">
                        <button onClick={handleRemix} className="group flex items-center gap-2 bg-zinc-900/90 backdrop-blur border border-zinc-700 hover:border-yellow-500 text-white px-8 py-3 rounded-full shadow-2xl transition-all hover:scale-105 active:scale-95">
                            <i className="ph ph-shuffle text-xl text-yellow-500 group-hover:animate-spin"></i>
                            <span className="font-bold tracking-wide group-hover:text-yellow-500 transition-colors">COLLIDE</span>
                        </button>
                    </div>

                    {/* ADD MODAL */}
                    {showAddModal && (
                        <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                            <div className="bg-zinc-900 border border-zinc-800 p-6 rounded-2xl w-full max-w-lg shadow-2xl fade-in">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-xl font-light text-white">Contribute to the Void</h2>
                                    <button onClick={() => setShowAddModal(false)} className="text-zinc-500 hover:text-white"><i className="ph ph-x text-xl"></i></button>
                                </div>
                                <textarea value={newContent} onChange={(e) => setNewContent(e.target.value)} placeholder="Type a lyric, a thought, or a fragment of a dream..." className="w-full h-40 bg-black border border-zinc-800 rounded-xl p-4 text-zinc-200 focus:border-yellow-500 outline-none resize-none mb-4" />
                                <button onClick={handleAddIdea} disabled={isSubmitting} className="w-full bg-white text-black font-bold py-3 rounded-xl hover:bg-zinc-200 transition-colors disabled:opacity-50">
                                    {isSubmitting ? "Transmitting..." : "Release to Nebula"}
                                </button>
                                <p className="text-center text-xs text-zinc-600 mt-4">Contributions are anonymous and permanent.</p>
                            </div>
                        </div>
                    )}

                    {/* REMIX MODAL */}
                    {showRemixModal && (
                        <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                            <div className="bg-zinc-900 border border-zinc-800 p-8 rounded-2xl w-full max-w-lg shadow-2xl flex flex-col max-h-[80vh] fade-in">
                                <button onClick={() => setShowRemixModal(false)} className="absolute top-4 right-4 text-zinc-500 hover:text-white"><i className="ph ph-x text-xl"></i></button>
                                <div className="text-center mb-6">
                                    <div className="inline-block px-3 py-1 rounded-full bg-yellow-500/10 text-yellow-500 text-xs font-bold tracking-widest mb-2">COLLISION DETECTED</div>
                                </div>
                                <div className="flex-grow overflow-y-auto custom-scroll bg-black/50 p-6 rounded-xl border border-zinc-800/50 mb-6">
                                    <p className="text-lg md:text-xl text-zinc-100 font-serif leading-loose whitespace-pre-wrap text-center">{remixResult}</p>
                                </div>
                                <div className="flex justify-center">
                                    <button onClick={handleRemix} className="flex items-center gap-2 text-sm text-zinc-400 hover:text-white transition-colors">
                                        <i className="ph ph-shuffle"></i> Reroll
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* DETAIL SIDEBAR */}
                    <div className={`absolute top-0 right-0 h-full w-full md:w-96 bg-black/95 backdrop-blur border-l border-zinc-800 shadow-2xl transition-transform duration-300 z-40 p-8 overflow-y-auto ${selectedNode ? 'translate-x-0' : 'translate-x-full'}`}>
                        <button onClick={() => setSelectedNode(null)} className="absolute top-6 right-6 text-zinc-500 hover:text-white"><i className="ph ph-x text-xl"></i></button>
                        <div className="mt-12">
                            <div className="inline-block px-2 py-1 rounded bg-zinc-800 text-zinc-400 text-[10px] font-bold tracking-widest mb-4">ANONYMOUS SIGNAL</div>
                            <p className="text-zinc-300 font-mono text-sm leading-relaxed whitespace-pre-wrap border-l-2 border-zinc-800 pl-4">{selectedNode?.content}</p>
                            <div className="mt-8 pt-8 border-t border-zinc-900 text-xs text-zinc-600 font-mono">
                                RECEIVED: {selectedNode?.timestamp?.toDate ? selectedNode.timestamp.toDate().toLocaleDateString() : 'Just now'}
                            </div>
                        </div>
                    </div>

                    {/* TOOLTIP */}
                    {hoveredNode && !selectedNode && (
                        <div className="fixed pointer-events-none z-50 bg-black border border-zinc-800 px-3 py-2 rounded-lg shadow-xl" style={{ left: hoveredNode.x + 15, top: hoveredNode.y + 15 }}>
                            <div className="text-xs text-zinc-400 max-w-[200px] truncate">{hoveredNode.content}</div>
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<IdeaNebula />);
    </script>
</body>
</html>